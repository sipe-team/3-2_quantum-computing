# 그루버 알고리즘

- 정렬되지 않은 정보를 빠르게 검색할 수 있게 해주는 알고리즘

네 자리 비밀번호를 알아내는 문제가 있을 때

→ 일반 컴퓨터에서는 O(N). 최악의 경우에 10000번 연산해야됨

→ 양자에서는 O( √n ) 즉 최악의 경우에 100번 연산해야됨

### 알고리즘 설명

```kotlin
H 게이트 - 오라클 게이트 - 디퓨저 게이트
```

세 단계를 거치면서, 반복적으로 연산해서 정답을 찾음

1. 처음에 H 게이트로 중첩시켜줌
2. 두 번째 오라클 게이트는 정답을 확인시켜줌
    - 답이 아닌 값을 넣었을 때는 가만히 있고
    - 답인 값을 넣으면 반응함 (위상(부호)을 반전함)

   → 중첩인 값을 넣었을 때 정답인 값만 -가 되고, 오답인 값들은 + 유지

3. 세 번째 디퓨져 게이트는 확률을 증폭시켜줌
    - 정답에 해당하는 데이터를 점점 강조함
    - 정답에 해당하는 데이터를 점점 강조해서 최종적으로 관측했을 때 정답이 나올 확률을 높임

2, 3번을 반복 → 반복 횟수는 √n에 비례함

### 활용

- 데이터 검색
- 암호 해독
    - AES 암호 브루트 포스 공격으로 해독 가능

      키 길이가 128일 때 원래는 2^128번 연산의 시도가 필요했지만, 양자 컴퓨터는 2^64번의 시도로 해결 가능

- NP-완전 문제 해결
    - NP-완전  문제) 다항시간에 풀 수 있을지 없을지 모르겠는데 아직 다항시간에 못 푼 문제
        - ex) 0-1 Knapsack, N-Queens 문제 등


---

# 쇼어 알고리즘

- 소인수 분해를 단항 시간 내에서 해결할 수 있는 알고리즘

### 알고리즘 설명

두 개의 큰 소수 p, q의 곱인 N이 있을 때 p, q를 알아내야 된다.

1. 1보다 크고 N보다 작은 정수 a를 임의로 선택
2. gcd(N, a) ≠ 1이면 p를 찾은 것
3. **f(x) = a^x(mod N)의 주기 찾기**
    1. **주기 r이 작수가 아니면 1번부터 다시 시작**
4. 주기 r로부터 두 개의 최대공약수 gcd1, gcd2 찾기
    1. gcd1 = gcd(N, a^r/2 + 1), gcd2 = gcd(N, a^r/2 - 1)
5. gcd1, gcd2가 1과 N이면 1번부터 다시 시작

일반 컴퓨터와 다르게 양자 컴퓨터는 양자 중첩, 간섭을 활용해서 3번 절차를 효율적으로 수행

### 활용

- 두 소수의 합성수 N(== p X q)를 이용해서 p, q를 공개키, 비밀키로 사용하는게 RSA 암호화임

  쇼어 알고리즘으로는 RSA를 다항 시간 내에 풀 수 있음

- 주기 찾기
- 이산 로그 문제
    - 주어진 g, h에 대해서 g^x = h mod p 를 만족하는 x를 찾는 문제
    - → 이산 로그를 활용한 암호화 기법인 ECC, DSA를 단항 시간 내로 풀어낼 수 있게 됨