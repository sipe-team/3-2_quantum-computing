## 양자컴퓨터의 기초 되짚어보기

비트연산을 위해 AND, OR, NOT, XOR 게이트를 사용하듯,   
큐비트연산을 위해서는 어떤 게이트를 사용해야 하는가?   
큐비트연산을 가능하도록 만들어주는 양자회로, 즉 게이트 구성하는 방법을 먼저 알아보자.

**X게이트**

비트연산의 NOT 게이트와 같다.   
0을 넣으면 1이 나오고, 1을 넣으면 0이 나온다.

**H게이트**

중첩상태로 만들어주는 게이트.   
0을 집어넣으면 0과 1이 동시에 존재하는, 즉 확률진폭이 루트 1/2이 나오도록 하는 게이트

**Z게이트**

위상을 바꿔주는 게이트.   
0을 넣었을 때는 반응이 없지만, 1을 넣으면 - 가 붙어서 나옴.

**CX(Control X) 게이트**

여기서부터는 두 개 이상의 큐비트를 활용해서 구성 가능한 게이트.   
CX게이트는 두 개의 큐비트를 얽히게 만든다.   
첫번째 큐비트에 1을 보내면 두번째 큐비트가 얽혀서 1이 나온다.   

재밌는 것은 첫 큐비트에 0, 1이 아닌 0과 1의 중첩상태도 넣을 수 있다는 것.   
H게이트를 통과시킨 중첩상태의 큐비트를 CX에 통과시키면 둘다 00이거나 둘다11인 상태가 나온다.   
이런 상태를 양자얽힘상태를 만든다고 한다.

**CZ(Control Z) 게이트**

첫번째 두번째가 둘다 1일때만 반응하는 게이트.
11을 넣으면 1 -1이 나온다. (위상변경)

**CCX게이트**

110을 넣어주면 111이 되는 게이트. 첫번째 두번째값이 세번째 값에 영향을 미친다.



## 그로버(Grover) 알고리즘

1. 중첩을 시키는 H Gate
2. 답을 확인하는 오라클
3. 확률을 증폭하는 디퓨저

어떠한 데이터셋에서 특정 값(예를 들면 최댓값)을 구하도록 로직을 구성해 놓으면, 해당 로직이 다른 데이터셋에서도 최댓값에 반응하게 된다.
따라서 제한된 데이터 내에서 가장 큰 수 찾는 알고리즘으로 쓸 수 있는 것.

## 쇼어(Shor) 알고리즘

*ChatGPT o1이 초안 생성 / 이후 문준호가 수정함...*

쇼어 알고리즘은 주어진 큰 정수를 빠르게 소인수분해 할 수 있는 양자 알고리즘으로, 고전 알고리즘에 비해 지수적으로 빠른 속도를 낸다. O(N^2)이 걸리는 것을 O(N)에 해결할 수 있는 것.   

소인수분해를 빠르게 해내면 뭐가 좋은가?   
오늘날 널리 쓰이는 RSA 암호체계가 큰 소수를 곱한 수(큰 정수의 소인수분해가 어렵다는 점)에 의존하여 보안을 유지하기 때문이다. 쇼어 알고리즘이 실현 가능한 수준으로 발전한다면 현재 RSA 기반 암호체계가 붕괴될 수 있으므로, 양자컴퓨터의 대표적인 ‘킬러앱’ 중 하나로 거론된다.

쇼어 알고리즘의 핵심 아이디어는 “함수의 주기를 찾으면 소인수를 구할 수 있다”는 점에 있다. 이를 구현하기 위해 **양자 푸리에 변환(QFT, Quantum Fourier Transform)** 을 사용한다. 전반적인 알고리즘 흐름은 다음과 같다.

1. **중첩 상태 생성**   
   먼저 n비트(또는 그 이상)의 큐비트를 준비한다. 그리고 H게이트 등을 이용하여 0과 1이 겹쳐진 중첩 상태를 만든다. 이렇게 하면 2^n개의 상태가 동시에 존재하므로, 매우 큰 범위의 수를 한꺼번에 탐색할 수 있는 기반이 마련된다.

2. **모듈러 지수 연산(Controlled 연산 활용)**   
   쇼어 알고리즘에서는 특정한 x에 대해 x^a \mod N 의 결과를 계산하는 회로가 필요하다. 이때, 여러 개의 큐비트에 걸쳐서 조건부로(Controlled) 연산이 이뤄져야 하므로, **CX, CZ, CCX**와 같은 여러 제어 게이트 조합이 사용된다. 이 회로가 효율적으로 구성되면, 지수 연산 전체를 병렬적으로 수행하는 것과 같은 효과를 낼 수 있다.

3. **양자 푸리에 변환(QFT)**   
   모듈러 지수 연산을 수행한 큐비트 상태에 QFT를 적용하면, 원하는 주기 정보가 큐비트의 위상 정보에 반영된다.   
   - QFT는 고전적인 푸리에 변환을 양자 상태에 적용한 것으로, 큐비트의 확률진폭에 푸리에 상관관계를 부여한다.  
   - 쇼어 알고리즘의 핵심은 이 QFT를 통해 생성된 위상 정보를 측정하여 주기를 알아내는 것이다.

4. **측정 및 고전(클래식) 연산**   
   QFT가 끝난 후 큐비트를 측정하면, 특정 비트열(고전 정보)을 얻게 된다. 이 비트열에는 함수의 주기가 담겨 있으며, 그 값을 토대로 소인수(인수)를 구하는 후처리를 수행한다. 이 과정은 고전적인 수학(유클리드 알고리즘 등)을 이용하여 진행한다.

5. **정답 검증**   
   측정 결과로 얻어진 후보 인수들을 대입해보면서 실제로 N으로 나누어 떨어지는지 확인한다. 이 과정을 통해 소인수를 찾아내게 된다.

결국 쇼어 알고리즘은 **양자 중첩으로 지수적인 후보를 빠르게 만들어내고, 제어 게이트로 이뤄진 모듈러 지수 연산**, 그리고 **QFT**의 결합을 통해 큰 수의 소인수분해 문제를 짧은 시간 안에 해결한다. 이는 고전 컴퓨터로는 사실상 불가능(또는 매우 오랜 시간 소요)했던 대규모 소인수분해를 빠르게 가능하게 만들어 준다.
